switch (rule->non_terminal->type) {
	case NON_TERMINAl_CONDITION_GOOD:
		condition_good_t *condition_good = (condition_good_t *)calloc(1, sizeof(condition_good_t));
		condition_good->good = elements[i].element->lexeme;
		i++;

	case NON_TERMINAl_CONDITION_BAD:
		condition_bad_t *condition_bad = (condition_bad_t *)calloc(1, sizeof(condition_bad_t));
		condition_bad->bad = elements[i].element->lexeme;
		i++;

	case NON_TERMINAL_CONDITION:
		condition_t *condition = (condition_t *)calloc(1, sizeof(condition_t));
		switch (rule->annotation) {
			case "GOOD":
				condition->type = CONDITION_GOOD;
				condition->condition.good = (condition_good_t *)calloc(1, sizeof(condition_good_t));
				condition->condition.good = elements[i].element->non_terminal.non_terminal->condition_good;

			case "BAD":
				condition->type = CONDITION_BAD;
				condition->condition.bad = (condition_bad_t *)calloc(1, sizeof(condition_bad_t));
				condition->condition.bad = elements[i].element->non_terminal.non_terminal->condition_bad;
		}
		i++;

	case NON_TERMINAL_SENTENCE:
		  sentence_t *sentence = (sentence_t *)calloc(1, sizeof(sentence_t));
		  sentence->she = elements[i].element->lexeme;
		  i++;
		  sentence->is = elements[i].element->lexeme;
		  i++;
		  sentence->condition = elements[i].element->non_terminal.non_terminal;
		  i++;
}
